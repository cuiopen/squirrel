/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef number_message_TYPES_H
#define number_message_TYPES_H

#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>



namespace squirrel { namespace common {

struct NumberRequestType {
  enum type {
    NUMBER_REQUEST_TYPE_INC = 0,
    NUMBER_REQUEST_TYPE_DEC = 1,
    NUMBER_REQUEST_TYPE_RESET = 2,
    NUMBER_REQUEST_TYPE_DELETE = 3,
    NUMBER_REQUEST_TYPE_MAX = 4
  };
};

extern const std::map<int, const char*> _NumberRequestType_VALUES_TO_NAMES;

struct NumberResponseType {
  enum type {
    NUMBER_RESPONSE_TYPE_SUCCESS = 0,
    NUMBER_RESPONSE_TYPE_KEY_NOT_EXIST = 1,
    NUMBER_RESPONSE_TYPE_DISCONNECTED = 2,
    NUMBER_RESPONSE_TYPE_UNKNOWN = 3,
    NUMBER_RESPONSE_TYPE_MAX = 4
  };
};

extern const std::map<int, const char*> _NumberResponseType_VALUES_TO_NAMES;

typedef struct _NumberRequest__isset {
  _NumberRequest__isset() : increment_(false) {}
  bool increment_;
} _NumberRequest__isset;

class NumberRequest {
 public:

  static const char* ascii_fingerprint; // = "24652790C81ECE22B629CB60A19F1E93";
  static const uint8_t binary_fingerprint[16]; // = {0x24,0x65,0x27,0x90,0xC8,0x1E,0xCE,0x22,0xB6,0x29,0xCB,0x60,0xA1,0x9F,0x1E,0x93};

  NumberRequest() : type_((NumberRequestType::type)0), increment_("") {
  }

  virtual ~NumberRequest() throw() {}

  NumberRequestType::type type_;
  std::string increment_;

  _NumberRequest__isset __isset;

  void __set_type_(const NumberRequestType::type val) {
    type_ = val;
  }

  void __set_increment_(const std::string& val) {
    increment_ = val;
    __isset.increment_ = true;
  }

  bool operator == (const NumberRequest & rhs) const
  {
    if (!(type_ == rhs.type_))
      return false;
    if (__isset.increment_ != rhs.__isset.increment_)
      return false;
    else if (__isset.increment_ && !(increment_ == rhs.increment_))
      return false;
    return true;
  }
  bool operator != (const NumberRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NumberRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NumberResponse__isset {
  _NumberResponse__isset() : value_(false) {}
  bool value_;
} _NumberResponse__isset;

class NumberResponse {
 public:

  static const char* ascii_fingerprint; // = "19AAB18E981C4EB11AEBB34F40FF0939";
  static const uint8_t binary_fingerprint[16]; // = {0x19,0xAA,0xB1,0x8E,0x98,0x1C,0x4E,0xB1,0x1A,0xEB,0xB3,0x4F,0x40,0xFF,0x09,0x39};

  NumberResponse() : type_((NumberRequestType::type)0), result_((NumberResponseType::type)0), value_("") {
  }

  virtual ~NumberResponse() throw() {}

  NumberRequestType::type type_;
  NumberResponseType::type result_;
  std::string value_;

  _NumberResponse__isset __isset;

  void __set_type_(const NumberRequestType::type val) {
    type_ = val;
  }

  void __set_result_(const NumberResponseType::type val) {
    result_ = val;
  }

  void __set_value_(const std::string& val) {
    value_ = val;
    __isset.value_ = true;
  }

  bool operator == (const NumberResponse & rhs) const
  {
    if (!(type_ == rhs.type_))
      return false;
    if (!(result_ == rhs.result_))
      return false;
    if (__isset.value_ != rhs.__isset.value_)
      return false;
    else if (__isset.value_ && !(value_ == rhs.value_))
      return false;
    return true;
  }
  bool operator != (const NumberResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NumberResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

}} // namespace

#endif
